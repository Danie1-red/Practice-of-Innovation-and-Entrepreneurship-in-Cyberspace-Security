# SM2算法软件实现技术总结

## 一、整体结构
SM2算法实现采用三层架构设计：

1. **底层大数据运算**  
   - 256比特多精度整数运算（加减乘模逆）
   - 核心：64比特无符号数组小端存储（4元素表示256比特）

2. **中层椭圆曲线点运算**  
   - 基础操作：点加（ADD）、倍点（DOUBLE）
   - 核心操作：点乘（kP），分固定点（kG）和非固定点（kP）

3. **上层协议实现**  
   - 数字签名（签名/验签）
   - 数据加密/解密
   - 密钥协商

---

## 二、大数据运算优化

### 核心算术操作
- **加减法实现**：
  ```c
  // X86-64专用指令
  carry = _addcarry_u64(carry, a[i], b[i], &d[i]); // 带进位加法
  carry = _subborrow_u64(carry, d[i], p[i], &d[i]); // 带借位减法
  ```
- **安全模约减**（防时序攻击）：
  - 通过标志寄存器判断结果是否≥p
  - 无分支选择结果：复制寄存器→执行减法→条件转移存储结果

### 乘法优化技术
- **现代指令集**：
  - BMI2的`MULX`（无标志影响）
  - `ADOX`/`ADCX`双流水线并行加法
- **模约减方案对比**：
  | **方法**         | **适用场景** | **优势**                  |
  |------------------|------------|--------------------------|
  | 蒙哥马利快速模约 | SM2素数p   | 利用p=2²⁵⁶-2²²⁴-2⁹⁶+2⁶⁴-1特性 |
  | Barrett模约      | 通用素数    | 无预计算表需求            |
  | 预计算表法       | 高频运算    | 空间换时间（存0,p,2p,3p,4p）|

### 模逆运算性能
| **方法**      | **周期数(cycles)** | **特点**                  |
|---------------|-------------------|--------------------------|
| SafeGCD       | ~3165             | 当前通用寄存器最优方案     |
| FLT费马小定理 | ~24235            | 需255次平方+15次乘法      |
| 蒙哥马利模逆  | ~4498             | 需结果修正                |

---

## 三、点乘运算优化

### 固定点点乘（kG）
- **预计算表技术**：
  - 比特重组：将256位k分为32组×8比特
  - 计算流程：
    ```
    初始化 Q = TBL[kb[31]]
    FOR i=30 DOWNTO 0:
        Q = DOUBLE(Q)         // 4M+4S
        Q = ADD(Q, TBL[kb[i]]) // 8M+3S (查表优化)
    ```
- **窗口宽度权衡**：
  | **窗口w** | **预计算点数** | **点运算总量** |
  |----------|---------------|---------------|
  | 8        | 256           | 31 DOUBLE + 31 ADD |
  | 12       | 4096          | 21 DOUBLE + 21 ADD |

### 非固定点点乘（kP）
- **NAF编码优化**：
  - 原理：Non-Adjacent Form消除连续1（汉明重量降至≈1/3）
  - 编码算法：
    ```python
    while k > 0:
        if k 为奇数: 
            ki = k mod 2^w  # 值取±1,±3,...,±(2^{w-1}-1)
            k = (k - ki)/2
        else:
            ki = 0
            k = k/2
    ```
- **窗口宽度选择**：
  | **w** | **非零元素** | **预计算点** | **总计算量**     |
  |-------|-------------|-------------|------------------|
  | 4     | 50          | 3           | INV+1454M+1182S |
  | 5     | 42          | 7           | INV+1423M+1171S |
  | 8     | 29          | 63          | INV+1694M+1303S |

- **革命性优化-Co-Z坐标**：
  - 核心：共享Z坐标降低点加开销
  - 复杂度：**6M+3S**（原12M+4S）
  - 安全实现：Co-Z XY方法（常量时间，8M+3S/bit）

### 双点运算（2P+Q）
- **JSF-5联合稀疏编码**：
  - 12种状态组合（需预计算P+Q, P-Q）
  - 优化公式：`2P+Q = (P+Q) + P` → **13M+5S+13A**
- **Co-Z加速**：同步计算P+Q和P-Q

---

## 四、协议层关键优化

### 签名验证
- **免模逆技术**：
  ```
  标准公式：x1 = (r-e) mod n
  优化实现：X = (r-e)·Z² mod p 或 ((r-e)+N)·Z² mod p
  ```

### 密钥协商
- **窗口加速**：w=127时步骤6-7可减少点加次数

---

## 五、性能基准数据
- **模逆运算**：SafeGCD ~3165 cycles
- **点加运算**：
  - 常规：570 cycles (12M+4S→8M+3S)
  - Co-Z优化：显著低于常规
- **倍点运算**：450 cycles (4M+4S)

> **注**：所有数据基于X86-64平台，使用BMI2/ADX指令集实测得出。

---
**核心参考文献**：  
1. 《椭圆曲线密码学指南》(Guide to Elliptic Curve Cryptography)  
2. CHES2020论文《更快的蒙哥马利阶梯算法》  
3. 观源科技《SM2高速等时模逆算法》(2021)